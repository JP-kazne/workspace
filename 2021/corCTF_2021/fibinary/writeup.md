# Writeup

以下のプログラムと暗号文が与えられる。

```py
fib = [1, 1]
for i in range(2, 11):
	fib.append(fib[i - 1] + fib[i - 2])

def c2f(c):
	n = ord(c)
	b = ''
	for i in range(10, -1, -1):
		if n >= fib[i]:
			n -= fib[i]
			b += '1'
		else:
			b += '0'
	return b

flag = open('flag.txt', 'r').read()
enc = ''
for c in flag:
	enc += c2f(c) + ' '
with open('flag.enc', 'w') as f:
	f.write(enc.strip())
```

```
10000100100 10010000010 10010001010 10000100100 10010010010 10001000000 10100000000 10000100010 00101010000 10010010000 00101001010 10000101000 10000010010 00101010000 10010000000 10000101000 10000010010 10001000000 00101000100 10000100010 10010000100 00010101010 00101000100 00101000100 00101001010 10000101000 10100000100 00000100100
```

このプログラムの暗号化は以下の手順で行われている。

1. 11個のフィボナッチ数列 `[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]` を作る

2. 文字列をASCIIに変換する

3. フィボナッチ数列の数の大きいほうから順に減算していき、ASCIIコードを和の形に分解する

```
例) 文字 c を暗号化
ASCII
    c = 99
和に分解
    99 = 89 + 8 + 2
    1*89 + 0*55 + 0*34 + 0*21 + 0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 0*1 + 0*1 = 1000100100
```

復号化は逆操作を行えばよい。

```py
fib = [1, 1]
for i in range(2, 11):
    fib.append(fib[i - 1] + fib[i - 2])

def f2c(b):
    n = 0
    c = ''
    for i in range(10):
        if b[i] == '1':
            n += fib[10-i]
    c += chr(n)
    return c

with open('flag.enc','r') as f:
    enc = f.read().split(' ')
    dec = ''.join([f2c(e) for e in enc])

print(dec)
```

<!-- corctf{b4s3d_4nd_f1bp!113d} -->
